{"message":"proc-macro derive panicked","code":null,"level":"error","spans":[{"file_name":"src/pb/sf.substreams.v1.rs","byte_start":1386,"byte_end":1402,"line_start":39,"line_end":39,"column_start":14,"column_end":30,"is_primary":true,"text":[{"text":"    #[derive(::prost::Message)]","highlight_start":14,"highlight_end":30}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"message: called `Result::unwrap()` on an `Err` value: Message can not be derived for an enum\n\nStack backtrace:\n   0: anyhow::error::<impl anyhow::Error>::msg\n   1: anyhow::__private::format_err\n   2: prost_derive::try_message\n   3: prost_derive::message\n   4: core::ops::function::Fn::call\n   5: proc_macro::bridge::client::Client<proc_macro::TokenStream,proc_macro::TokenStream>::expand1::{{closure}}::{{closure}}\n   6: proc_macro::bridge::client::run_client::{{closure}}::{{closure}}::{{closure}}\n   7: proc_macro::bridge::scoped_cell::ScopedCell<T>::set::{{closure}}\n   8: proc_macro::bridge::scoped_cell::ScopedCell<T>::replace\n   9: proc_macro::bridge::client::run_client::{{closure}}::{{closure}}\n  10: std::thread::local::LocalKey<T>::try_with\n  11: proc_macro::bridge::client::run_client::{{closure}}\n  12: <core::panic::unwind_safe::AssertUnwindSafe<F> as core::ops::function::FnOnce<()>>::call_once\n  13: std::panicking::try::do_call\n  14: __rust_try\n  15: std::panicking::try\n  16: proc_macro::bridge::client::run_client\n  17: proc_macro::bridge::client::Client<proc_macro::TokenStream,proc_macro::TokenStream>::expand1::{{closure}}\n  18: proc_macro::bridge::selfless_reify::reify_to_extern_c_fn_hrt_bridge::wrapper\n  19: <proc_macro::bridge::server::MaybeCrossThread<rustc_expand::proc_macro::CrossbeamMessagePipe<proc_macro::bridge::buffer::Buffer>> as proc_macro::bridge::server::ExecutionStrategy>::run_bridge_and_client::<proc_macro::bridge::server::Dispatcher<proc_macro::bridge::server::MarkedTypes<rustc_expand::proc_macro_server::Rustc>>>\n  20: <proc_macro::bridge::client::Client<proc_macro::TokenStream, proc_macro::TokenStream>>::run::<rustc_expand::proc_macro_server::Rustc, proc_macro::bridge::server::MaybeCrossThread<rustc_expand::proc_macro::CrossbeamMessagePipe<proc_macro::bridge::buffer::Buffer>>>\n  21: <rustc_expand::proc_macro::DeriveProcMacro as rustc_expand::base::MultiItemModifier>::expand\n  22: <rustc_expand::expand::MacroExpander>::fully_expand_fragment\n  23: <rustc_expand::expand::MacroExpander>::expand_crate\n  24: rustc_interface::passes::resolver_for_lowering\n  25: rustc_query_impl::plumbing::__rust_begin_short_backtrace::<rustc_query_impl::query_impl::resolver_for_lowering::dynamic_query::{closure#2}::{closure#0}, rustc_middle::query::erase::Erased<[u8; 8]>>\n  26: rustc_query_system::query::plumbing::try_execute_query::<rustc_query_impl::DynamicConfig<rustc_query_system::query::caches::SingleCache<rustc_middle::query::erase::Erased<[u8; 8]>>, false, false, false>, rustc_query_impl::plumbing::QueryCtxt, false>\n  27: rustc_query_impl::query_impl::resolver_for_lowering::get_query_non_incr::__rust_end_short_backtrace\n  28: rustc_interface::interface::run_compiler::<core::result::Result<(), rustc_span::ErrorGuaranteed>, rustc_driver_impl::run_compiler::{closure#1}>::{closure#0}\n  29: std::sys_common::backtrace::__rust_begin_short_backtrace::<rustc_interface::util::run_in_thread_with_globals<rustc_interface::interface::run_compiler<core::result::Result<(), rustc_span::ErrorGuaranteed>, rustc_driver_impl::run_compiler::{closure#1}>::{closure#0}, core::result::Result<(), rustc_span::ErrorGuaranteed>>::{closure#0}::{closure#0}, core::result::Result<(), rustc_span::ErrorGuaranteed>>\n  30: <<std::thread::Builder>::spawn_unchecked_<rustc_interface::util::run_in_thread_with_globals<rustc_interface::interface::run_compiler<core::result::Result<(), rustc_span::ErrorGuaranteed>, rustc_driver_impl::run_compiler::{closure#1}>::{closure#0}, core::result::Result<(), rustc_span::ErrorGuaranteed>>::{closure#0}::{closure#0}, core::result::Result<(), rustc_span::ErrorGuaranteed>>::{closure#1} as core::ops::function::FnOnce<()>>::call_once::{shim:vtable#0}\n  31: <alloc::boxed::Box<F,A> as core::ops::function::FnOnce<Args>>::call_once\n             at /rustc/82e1608dfa6e0b5569232559e3d385fea5a93112/library/alloc/src/boxed.rs:2007:9\n  32: <alloc::boxed::Box<F,A> as core::ops::function::FnOnce<Args>>::call_once\n             at /rustc/82e1608dfa6e0b5569232559e3d385fea5a93112/library/alloc/src/boxed.rs:2007:9\n  33: std::sys::unix::thread::Thread::new::thread_start\n             at /rustc/82e1608dfa6e0b5569232559e3d385fea5a93112/library/std/src/sys/unix/thread.rs:108:17\n  34: start_thread\n             at /build/glibc-LcI20x/glibc-2.31/nptl/pthread_create.c:477:8\n  35: clone\n             at /build/glibc-LcI20x/glibc-2.31/misc/../sysdeps/unix/sysv/linux/x86_64/clone.S:95","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: proc-macro derive panicked\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/pb/sf.substreams.v1.rs:39:14\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m39\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    #[derive(::prost::Message)]\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: message: called `Result::unwrap()` on an `Err` value: Message can not be derived for an enum\u001b[0m\n\u001b[0m           \u001b[0m\n\u001b[0m           Stack backtrace:\u001b[0m\n\u001b[0m              0: anyhow::error::<impl anyhow::Error>::msg\u001b[0m\n\u001b[0m              1: anyhow::__private::format_err\u001b[0m\n\u001b[0m              2: prost_derive::try_message\u001b[0m\n\u001b[0m              3: prost_derive::message\u001b[0m\n\u001b[0m              4: core::ops::function::Fn::call\u001b[0m\n\u001b[0m              5: proc_macro::bridge::client::Client<proc_macro::TokenStream,proc_macro::TokenStream>::expand1::{{closure}}::{{closure}}\u001b[0m\n\u001b[0m              6: proc_macro::bridge::client::run_client::{{closure}}::{{closure}}::{{closure}}\u001b[0m\n\u001b[0m              7: proc_macro::bridge::scoped_cell::ScopedCell<T>::set::{{closure}}\u001b[0m\n\u001b[0m              8: proc_macro::bridge::scoped_cell::ScopedCell<T>::replace\u001b[0m\n\u001b[0m              9: proc_macro::bridge::client::run_client::{{closure}}::{{closure}}\u001b[0m\n\u001b[0m             10: std::thread::local::LocalKey<T>::try_with\u001b[0m\n\u001b[0m             11: proc_macro::bridge::client::run_client::{{closure}}\u001b[0m\n\u001b[0m             12: <core::panic::unwind_safe::AssertUnwindSafe<F> as core::ops::function::FnOnce<()>>::call_once\u001b[0m\n\u001b[0m             13: std::panicking::try::do_call\u001b[0m\n\u001b[0m             14: __rust_try\u001b[0m\n\u001b[0m             15: std::panicking::try\u001b[0m\n\u001b[0m             16: proc_macro::bridge::client::run_client\u001b[0m\n\u001b[0m             17: proc_macro::bridge::client::Client<proc_macro::TokenStream,proc_macro::TokenStream>::expand1::{{closure}}\u001b[0m\n\u001b[0m             18: proc_macro::bridge::selfless_reify::reify_to_extern_c_fn_hrt_bridge::wrapper\u001b[0m\n\u001b[0m             19: <proc_macro::bridge::server::MaybeCrossThread<rustc_expand::proc_macro::CrossbeamMessagePipe<proc_macro::bridge::buffer::Buffer>> as proc_macro::bridge::server::ExecutionStrategy>::run_bridge_and_client::<proc_macro::bridge::server::Dispatcher<proc_macro::bridge::server::MarkedTypes<rustc_expand::proc_macro_server::Rustc>>>\u001b[0m\n\u001b[0m             20: <proc_macro::bridge::client::Client<proc_macro::TokenStream, proc_macro::TokenStream>>::run::<rustc_expand::proc_macro_server::Rustc, proc_macro::bridge::server::MaybeCrossThread<rustc_expand::proc_macro::CrossbeamMessagePipe<proc_macro::bridge::buffer::Buffer>>>\u001b[0m\n\u001b[0m             21: <rustc_expand::proc_macro::DeriveProcMacro as rustc_expand::base::MultiItemModifier>::expand\u001b[0m\n\u001b[0m             22: <rustc_expand::expand::MacroExpander>::fully_expand_fragment\u001b[0m\n\u001b[0m             23: <rustc_expand::expand::MacroExpander>::expand_crate\u001b[0m\n\u001b[0m             24: rustc_interface::passes::resolver_for_lowering\u001b[0m\n\u001b[0m             25: rustc_query_impl::plumbing::__rust_begin_short_backtrace::<rustc_query_impl::query_impl::resolver_for_lowering::dynamic_query::{closure#2}::{closure#0}, rustc_middle::query::erase::Erased<[u8; 8]>>\u001b[0m\n\u001b[0m             26: rustc_query_system::query::plumbing::try_execute_query::<rustc_query_impl::DynamicConfig<rustc_query_system::query::caches::SingleCache<rustc_middle::query::erase::Erased<[u8; 8]>>, false, false, false>, rustc_query_impl::plumbing::QueryCtxt, false>\u001b[0m\n\u001b[0m             27: rustc_query_impl::query_impl::resolver_for_lowering::get_query_non_incr::__rust_end_short_backtrace\u001b[0m\n\u001b[0m             28: rustc_interface::interface::run_compiler::<core::result::Result<(), rustc_span::ErrorGuaranteed>, rustc_driver_impl::run_compiler::{closure#1}>::{closure#0}\u001b[0m\n\u001b[0m             29: std::sys_common::backtrace::__rust_begin_short_backtrace::<rustc_interface::util::run_in_thread_with_globals<rustc_interface::interface::run_compiler<core::result::Result<(), rustc_span::ErrorGuaranteed>, rustc_driver_impl::run_compiler::{closure#1}>::{closure#0}, core::result::Result<(), rustc_span::ErrorGuaranteed>>::{closure#0}::{closure#0}, core::result::Result<(), rustc_span::ErrorGuaranteed>>\u001b[0m\n\u001b[0m             30: <<std::thread::Builder>::spawn_unchecked_<rustc_interface::util::run_in_thread_with_globals<rustc_interface::interface::run_compiler<core::result::Result<(), rustc_span::ErrorGuaranteed>, rustc_driver_impl::run_compiler::{closure#1}>::{closure#0}, core::result::Result<(), rustc_span::ErrorGuaranteed>>::{closure#0}::{closure#0}, core::result::Result<(), rustc_span::ErrorGuaranteed>>::{closure#1} as core::ops::function::FnOnce<()>>::call_once::{shim:vtable#0}\u001b[0m\n\u001b[0m             31: <alloc::boxed::Box<F,A> as core::ops::function::FnOnce<Args>>::call_once\u001b[0m\n\u001b[0m                        at /rustc/82e1608dfa6e0b5569232559e3d385fea5a93112/library/alloc/src/boxed.rs:2007:9\u001b[0m\n\u001b[0m             32: <alloc::boxed::Box<F,A> as core::ops::function::FnOnce<Args>>::call_once\u001b[0m\n\u001b[0m                        at /rustc/82e1608dfa6e0b5569232559e3d385fea5a93112/library/alloc/src/boxed.rs:2007:9\u001b[0m\n\u001b[0m             33: std::sys::unix::thread::Thread::new::thread_start\u001b[0m\n\u001b[0m                        at /rustc/82e1608dfa6e0b5569232559e3d385fea5a93112/library/std/src/sys/unix/thread.rs:108:17\u001b[0m\n\u001b[0m             34: start_thread\u001b[0m\n\u001b[0m                        at /build/glibc-LcI20x/glibc-2.31/nptl/pthread_create.c:477:8\u001b[0m\n\u001b[0m             35: clone\u001b[0m\n\u001b[0m                        at /build/glibc-LcI20x/glibc-2.31/misc/../sysdeps/unix/sysv/linux/x86_64/clone.S:95\u001b[0m\n\n"}
{"message":"proc-macro derive panicked","code":null,"level":"error","spans":[{"file_name":"src/pb/sf.substreams.v1.rs","byte_start":2201,"byte_end":2217,"line_start":64,"line_end":64,"column_start":10,"column_end":26,"is_primary":true,"text":[{"text":"#[derive(::prost::Message)]","highlight_start":10,"highlight_end":26}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"message: called `Result::unwrap()` on an `Err` value: Message can not be derived for an enum\n\nStack backtrace:\n   0: anyhow::error::<impl anyhow::Error>::msg\n   1: anyhow::__private::format_err\n   2: prost_derive::try_message\n   3: prost_derive::message\n   4: core::ops::function::Fn::call\n   5: proc_macro::bridge::client::Client<proc_macro::TokenStream,proc_macro::TokenStream>::expand1::{{closure}}::{{closure}}\n   6: proc_macro::bridge::client::run_client::{{closure}}::{{closure}}::{{closure}}\n   7: proc_macro::bridge::scoped_cell::ScopedCell<T>::set::{{closure}}\n   8: proc_macro::bridge::scoped_cell::ScopedCell<T>::replace\n   9: proc_macro::bridge::client::run_client::{{closure}}::{{closure}}\n  10: std::thread::local::LocalKey<T>::try_with\n  11: proc_macro::bridge::client::run_client::{{closure}}\n  12: <core::panic::unwind_safe::AssertUnwindSafe<F> as core::ops::function::FnOnce<()>>::call_once\n  13: std::panicking::try::do_call\n  14: __rust_try\n  15: std::panicking::try\n  16: proc_macro::bridge::client::run_client\n  17: proc_macro::bridge::client::Client<proc_macro::TokenStream,proc_macro::TokenStream>::expand1::{{closure}}\n  18: proc_macro::bridge::selfless_reify::reify_to_extern_c_fn_hrt_bridge::wrapper\n  19: <proc_macro::bridge::server::MaybeCrossThread<rustc_expand::proc_macro::CrossbeamMessagePipe<proc_macro::bridge::buffer::Buffer>> as proc_macro::bridge::server::ExecutionStrategy>::run_bridge_and_client::<proc_macro::bridge::server::Dispatcher<proc_macro::bridge::server::MarkedTypes<rustc_expand::proc_macro_server::Rustc>>>\n  20: <proc_macro::bridge::client::Client<proc_macro::TokenStream, proc_macro::TokenStream>>::run::<rustc_expand::proc_macro_server::Rustc, proc_macro::bridge::server::MaybeCrossThread<rustc_expand::proc_macro::CrossbeamMessagePipe<proc_macro::bridge::buffer::Buffer>>>\n  21: <rustc_expand::proc_macro::DeriveProcMacro as rustc_expand::base::MultiItemModifier>::expand\n  22: <rustc_expand::expand::MacroExpander>::fully_expand_fragment\n  23: <rustc_expand::expand::MacroExpander>::expand_crate\n  24: rustc_interface::passes::resolver_for_lowering\n  25: rustc_query_impl::plumbing::__rust_begin_short_backtrace::<rustc_query_impl::query_impl::resolver_for_lowering::dynamic_query::{closure#2}::{closure#0}, rustc_middle::query::erase::Erased<[u8; 8]>>\n  26: rustc_query_system::query::plumbing::try_execute_query::<rustc_query_impl::DynamicConfig<rustc_query_system::query::caches::SingleCache<rustc_middle::query::erase::Erased<[u8; 8]>>, false, false, false>, rustc_query_impl::plumbing::QueryCtxt, false>\n  27: rustc_query_impl::query_impl::resolver_for_lowering::get_query_non_incr::__rust_end_short_backtrace\n  28: rustc_interface::interface::run_compiler::<core::result::Result<(), rustc_span::ErrorGuaranteed>, rustc_driver_impl::run_compiler::{closure#1}>::{closure#0}\n  29: std::sys_common::backtrace::__rust_begin_short_backtrace::<rustc_interface::util::run_in_thread_with_globals<rustc_interface::interface::run_compiler<core::result::Result<(), rustc_span::ErrorGuaranteed>, rustc_driver_impl::run_compiler::{closure#1}>::{closure#0}, core::result::Result<(), rustc_span::ErrorGuaranteed>>::{closure#0}::{closure#0}, core::result::Result<(), rustc_span::ErrorGuaranteed>>\n  30: <<std::thread::Builder>::spawn_unchecked_<rustc_interface::util::run_in_thread_with_globals<rustc_interface::interface::run_compiler<core::result::Result<(), rustc_span::ErrorGuaranteed>, rustc_driver_impl::run_compiler::{closure#1}>::{closure#0}, core::result::Result<(), rustc_span::ErrorGuaranteed>>::{closure#0}::{closure#0}, core::result::Result<(), rustc_span::ErrorGuaranteed>>::{closure#1} as core::ops::function::FnOnce<()>>::call_once::{shim:vtable#0}\n  31: <alloc::boxed::Box<F,A> as core::ops::function::FnOnce<Args>>::call_once\n             at /rustc/82e1608dfa6e0b5569232559e3d385fea5a93112/library/alloc/src/boxed.rs:2007:9\n  32: <alloc::boxed::Box<F,A> as core::ops::function::FnOnce<Args>>::call_once\n             at /rustc/82e1608dfa6e0b5569232559e3d385fea5a93112/library/alloc/src/boxed.rs:2007:9\n  33: std::sys::unix::thread::Thread::new::thread_start\n             at /rustc/82e1608dfa6e0b5569232559e3d385fea5a93112/library/std/src/sys/unix/thread.rs:108:17\n  34: start_thread\n             at /build/glibc-LcI20x/glibc-2.31/nptl/pthread_create.c:477:8\n  35: clone\n             at /build/glibc-LcI20x/glibc-2.31/misc/../sysdeps/unix/sysv/linux/x86_64/clone.S:95","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: proc-macro derive panicked\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/pb/sf.substreams.v1.rs:64:10\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m64\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m#[derive(::prost::Message)]\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: message: called `Result::unwrap()` on an `Err` value: Message can not be derived for an enum\u001b[0m\n\u001b[0m           \u001b[0m\n\u001b[0m           Stack backtrace:\u001b[0m\n\u001b[0m              0: anyhow::error::<impl anyhow::Error>::msg\u001b[0m\n\u001b[0m              1: anyhow::__private::format_err\u001b[0m\n\u001b[0m              2: prost_derive::try_message\u001b[0m\n\u001b[0m              3: prost_derive::message\u001b[0m\n\u001b[0m              4: core::ops::function::Fn::call\u001b[0m\n\u001b[0m              5: proc_macro::bridge::client::Client<proc_macro::TokenStream,proc_macro::TokenStream>::expand1::{{closure}}::{{closure}}\u001b[0m\n\u001b[0m              6: proc_macro::bridge::client::run_client::{{closure}}::{{closure}}::{{closure}}\u001b[0m\n\u001b[0m              7: proc_macro::bridge::scoped_cell::ScopedCell<T>::set::{{closure}}\u001b[0m\n\u001b[0m              8: proc_macro::bridge::scoped_cell::ScopedCell<T>::replace\u001b[0m\n\u001b[0m              9: proc_macro::bridge::client::run_client::{{closure}}::{{closure}}\u001b[0m\n\u001b[0m             10: std::thread::local::LocalKey<T>::try_with\u001b[0m\n\u001b[0m             11: proc_macro::bridge::client::run_client::{{closure}}\u001b[0m\n\u001b[0m             12: <core::panic::unwind_safe::AssertUnwindSafe<F> as core::ops::function::FnOnce<()>>::call_once\u001b[0m\n\u001b[0m             13: std::panicking::try::do_call\u001b[0m\n\u001b[0m             14: __rust_try\u001b[0m\n\u001b[0m             15: std::panicking::try\u001b[0m\n\u001b[0m             16: proc_macro::bridge::client::run_client\u001b[0m\n\u001b[0m             17: proc_macro::bridge::client::Client<proc_macro::TokenStream,proc_macro::TokenStream>::expand1::{{closure}}\u001b[0m\n\u001b[0m             18: proc_macro::bridge::selfless_reify::reify_to_extern_c_fn_hrt_bridge::wrapper\u001b[0m\n\u001b[0m             19: <proc_macro::bridge::server::MaybeCrossThread<rustc_expand::proc_macro::CrossbeamMessagePipe<proc_macro::bridge::buffer::Buffer>> as proc_macro::bridge::server::ExecutionStrategy>::run_bridge_and_client::<proc_macro::bridge::server::Dispatcher<proc_macro::bridge::server::MarkedTypes<rustc_expand::proc_macro_server::Rustc>>>\u001b[0m\n\u001b[0m             20: <proc_macro::bridge::client::Client<proc_macro::TokenStream, proc_macro::TokenStream>>::run::<rustc_expand::proc_macro_server::Rustc, proc_macro::bridge::server::MaybeCrossThread<rustc_expand::proc_macro::CrossbeamMessagePipe<proc_macro::bridge::buffer::Buffer>>>\u001b[0m\n\u001b[0m             21: <rustc_expand::proc_macro::DeriveProcMacro as rustc_expand::base::MultiItemModifier>::expand\u001b[0m\n\u001b[0m             22: <rustc_expand::expand::MacroExpander>::fully_expand_fragment\u001b[0m\n\u001b[0m             23: <rustc_expand::expand::MacroExpander>::expand_crate\u001b[0m\n\u001b[0m             24: rustc_interface::passes::resolver_for_lowering\u001b[0m\n\u001b[0m             25: rustc_query_impl::plumbing::__rust_begin_short_backtrace::<rustc_query_impl::query_impl::resolver_for_lowering::dynamic_query::{closure#2}::{closure#0}, rustc_middle::query::erase::Erased<[u8; 8]>>\u001b[0m\n\u001b[0m             26: rustc_query_system::query::plumbing::try_execute_query::<rustc_query_impl::DynamicConfig<rustc_query_system::query::caches::SingleCache<rustc_middle::query::erase::Erased<[u8; 8]>>, false, false, false>, rustc_query_impl::plumbing::QueryCtxt, false>\u001b[0m\n\u001b[0m             27: rustc_query_impl::query_impl::resolver_for_lowering::get_query_non_incr::__rust_end_short_backtrace\u001b[0m\n\u001b[0m             28: rustc_interface::interface::run_compiler::<core::result::Result<(), rustc_span::ErrorGuaranteed>, rustc_driver_impl::run_compiler::{closure#1}>::{closure#0}\u001b[0m\n\u001b[0m             29: std::sys_common::backtrace::__rust_begin_short_backtrace::<rustc_interface::util::run_in_thread_with_globals<rustc_interface::interface::run_compiler<core::result::Result<(), rustc_span::ErrorGuaranteed>, rustc_driver_impl::run_compiler::{closure#1}>::{closure#0}, core::result::Result<(), rustc_span::ErrorGuaranteed>>::{closure#0}::{closure#0}, core::result::Result<(), rustc_span::ErrorGuaranteed>>\u001b[0m\n\u001b[0m             30: <<std::thread::Builder>::spawn_unchecked_<rustc_interface::util::run_in_thread_with_globals<rustc_interface::interface::run_compiler<core::result::Result<(), rustc_span::ErrorGuaranteed>, rustc_driver_impl::run_compiler::{closure#1}>::{closure#0}, core::result::Result<(), rustc_span::ErrorGuaranteed>>::{closure#0}::{closure#0}, core::result::Result<(), rustc_span::ErrorGuaranteed>>::{closure#1} as core::ops::function::FnOnce<()>>::call_once::{shim:vtable#0}\u001b[0m\n\u001b[0m             31: <alloc::boxed::Box<F,A> as core::ops::function::FnOnce<Args>>::call_once\u001b[0m\n\u001b[0m                        at /rustc/82e1608dfa6e0b5569232559e3d385fea5a93112/library/alloc/src/boxed.rs:2007:9\u001b[0m\n\u001b[0m             32: <alloc::boxed::Box<F,A> as core::ops::function::FnOnce<Args>>::call_once\u001b[0m\n\u001b[0m                        at /rustc/82e1608dfa6e0b5569232559e3d385fea5a93112/library/alloc/src/boxed.rs:2007:9\u001b[0m\n\u001b[0m             33: std::sys::unix::thread::Thread::new::thread_start\u001b[0m\n\u001b[0m                        at /rustc/82e1608dfa6e0b5569232559e3d385fea5a93112/library/std/src/sys/unix/thread.rs:108:17\u001b[0m\n\u001b[0m             34: start_thread\u001b[0m\n\u001b[0m                        at /build/glibc-LcI20x/glibc-2.31/nptl/pthread_create.c:477:8\u001b[0m\n\u001b[0m             35: clone\u001b[0m\n\u001b[0m                        at /build/glibc-LcI20x/glibc-2.31/misc/../sysdeps/unix/sysv/linux/x86_64/clone.S:95\u001b[0m\n\n"}
{"message":"unused import: `ConfirmedTransaction`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/lib.rs","byte_start":136,"byte_end":156,"line_start":5,"line_end":5,"column_start":41,"column_end":61,"is_primary":true,"text":[{"text":"use pb::sf::solana::r#type::v1::{Block, ConfirmedTransaction};","highlight_start":41,"highlight_end":61}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unused_imports)]` on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"remove the unused import","code":null,"level":"help","spans":[{"file_name":"src/lib.rs","byte_start":134,"byte_end":156,"line_start":5,"line_end":5,"column_start":39,"column_end":61,"is_primary":true,"text":[{"text":"use pb::sf::solana::r#type::v1::{Block, ConfirmedTransaction};","highlight_start":39,"highlight_end":61}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unused import: `ConfirmedTransaction`\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib.rs:5:41\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m5\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m:v1::{Block, ConfirmedTransaction};\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `#[warn(unused_imports)]` on by default\u001b[0m\n\n"}
{"message":"conflicting implementations of trait `prost::Message` for type `EntityChanges`","code":{"code":"E0119","explanation":"There are conflicting trait implementations for the same type.\n\nErroneous code example:\n\n```compile_fail,E0119\ntrait MyTrait {\n    fn get(&self) -> usize;\n}\n\nimpl<T> MyTrait for T {\n    fn get(&self) -> usize { 0 }\n}\n\nstruct Foo {\n    value: usize\n}\n\nimpl MyTrait for Foo { // error: conflicting implementations of trait\n                       //        `MyTrait` for type `Foo`\n    fn get(&self) -> usize { self.value }\n}\n```\n\nWhen looking for the implementation for the trait, the compiler finds\nboth the `impl<T> MyTrait for T` where T is all types and the `impl\nMyTrait for Foo`. Since a trait cannot be implemented multiple times,\nthis is an error. So, when you write:\n\n```\ntrait MyTrait {\n    fn get(&self) -> usize;\n}\n\nimpl<T> MyTrait for T {\n    fn get(&self) -> usize { 0 }\n}\n```\n\nThis makes the trait implemented on all types in the scope. So if you\ntry to implement it on another one after that, the implementations will\nconflict. Example:\n\n```\ntrait MyTrait {\n    fn get(&self) -> usize;\n}\n\nimpl<T> MyTrait for T {\n    fn get(&self) -> usize { 0 }\n}\n\nstruct Foo;\n\nfn main() {\n    let f = Foo;\n\n    f.get(); // the trait is implemented so we can use it\n}\n```\n"},"level":"error","spans":[{"file_name":"src/pb/sf.substreams.v1.rs","byte_start":9,"byte_end":25,"line_start":1,"line_end":1,"column_start":10,"column_end":26,"is_primary":false,"text":[{"text":"#[derive(::prost::Message)]","highlight_start":10,"highlight_end":26}],"label":"first implementation here","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/pb/sf.substreams.v1.rs","byte_start":9,"byte_end":25,"line_start":1,"line_end":1,"column_start":10,"column_end":26,"is_primary":false,"text":[{"text":"#[derive(::prost::Message)]","highlight_start":10,"highlight_end":26}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(::prost::Message)]","def_site_span":{"file_name":"/home/codespace/.cargo/registry/src/index.crates.io-6f17d22bba15001f/prost-derive-0.11.9/src/lib.rs","byte_start":7524,"byte_end":7573,"line_start":242,"line_end":242,"column_start":1,"column_end":50,"is_primary":false,"text":[{"text":"pub fn message(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":50}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/pb/sf.substreams.v1.rs","byte_start":102,"byte_end":118,"line_start":3,"line_end":3,"column_start":28,"column_end":44,"is_primary":true,"text":[{"text":"#[derive(Clone, PartialEq, ::prost::Message)]","highlight_start":28,"highlight_end":44}],"label":"conflicting implementation for `EntityChanges`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/pb/sf.substreams.v1.rs","byte_start":102,"byte_end":118,"line_start":3,"line_end":3,"column_start":28,"column_end":44,"is_primary":false,"text":[{"text":"#[derive(Clone, PartialEq, ::prost::Message)]","highlight_start":28,"highlight_end":44}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(::prost::Message)]","def_site_span":{"file_name":"/home/codespace/.cargo/registry/src/index.crates.io-6f17d22bba15001f/prost-derive-0.11.9/src/lib.rs","byte_start":7524,"byte_end":7573,"line_start":242,"line_end":242,"column_start":1,"column_end":50,"is_primary":false,"text":[{"text":"pub fn message(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":50}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0119]\u001b[0m\u001b[0m\u001b[1m: conflicting implementations of trait `prost::Message` for type `EntityChanges`\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/pb/sf.substreams.v1.rs:3:28\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m#[derive(::prost::Message)]\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m----------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mfirst implementation here\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m#[allow(clippy::derive_partial_eq_without_eq)]\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m#[derive(Clone, PartialEq, ::prost::Message)]\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mconflicting implementation for `EntityChanges`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the derive macro `::prost::Message` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"conflicting implementations of trait `prost::Message` for type `EntityChange`","code":{"code":"E0119","explanation":"There are conflicting trait implementations for the same type.\n\nErroneous code example:\n\n```compile_fail,E0119\ntrait MyTrait {\n    fn get(&self) -> usize;\n}\n\nimpl<T> MyTrait for T {\n    fn get(&self) -> usize { 0 }\n}\n\nstruct Foo {\n    value: usize\n}\n\nimpl MyTrait for Foo { // error: conflicting implementations of trait\n                       //        `MyTrait` for type `Foo`\n    fn get(&self) -> usize { self.value }\n}\n```\n\nWhen looking for the implementation for the trait, the compiler finds\nboth the `impl<T> MyTrait for T` where T is all types and the `impl\nMyTrait for Foo`. Since a trait cannot be implemented multiple times,\nthis is an error. So, when you write:\n\n```\ntrait MyTrait {\n    fn get(&self) -> usize;\n}\n\nimpl<T> MyTrait for T {\n    fn get(&self) -> usize { 0 }\n}\n```\n\nThis makes the trait implemented on all types in the scope. So if you\ntry to implement it on another one after that, the implementations will\nconflict. Example:\n\n```\ntrait MyTrait {\n    fn get(&self) -> usize;\n}\n\nimpl<T> MyTrait for T {\n    fn get(&self) -> usize { 0 }\n}\n\nstruct Foo;\n\nfn main() {\n    let f = Foo;\n\n    f.get(); // the trait is implemented so we can use it\n}\n```\n"},"level":"error","spans":[{"file_name":"src/pb/sf.substreams.v1.rs","byte_start":259,"byte_end":275,"line_start":8,"line_end":8,"column_start":10,"column_end":26,"is_primary":false,"text":[{"text":"#[derive(::prost::Message)]","highlight_start":10,"highlight_end":26}],"label":"first implementation here","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/pb/sf.substreams.v1.rs","byte_start":259,"byte_end":275,"line_start":8,"line_end":8,"column_start":10,"column_end":26,"is_primary":false,"text":[{"text":"#[derive(::prost::Message)]","highlight_start":10,"highlight_end":26}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(::prost::Message)]","def_site_span":{"file_name":"/home/codespace/.cargo/registry/src/index.crates.io-6f17d22bba15001f/prost-derive-0.11.9/src/lib.rs","byte_start":7524,"byte_end":7573,"line_start":242,"line_end":242,"column_start":1,"column_end":50,"is_primary":false,"text":[{"text":"pub fn message(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":50}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/pb/sf.substreams.v1.rs","byte_start":352,"byte_end":368,"line_start":10,"line_end":10,"column_start":28,"column_end":44,"is_primary":true,"text":[{"text":"#[derive(Clone, PartialEq, ::prost::Message)]","highlight_start":28,"highlight_end":44}],"label":"conflicting implementation for `EntityChange`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/pb/sf.substreams.v1.rs","byte_start":352,"byte_end":368,"line_start":10,"line_end":10,"column_start":28,"column_end":44,"is_primary":false,"text":[{"text":"#[derive(Clone, PartialEq, ::prost::Message)]","highlight_start":28,"highlight_end":44}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(::prost::Message)]","def_site_span":{"file_name":"/home/codespace/.cargo/registry/src/index.crates.io-6f17d22bba15001f/prost-derive-0.11.9/src/lib.rs","byte_start":7524,"byte_end":7573,"line_start":242,"line_end":242,"column_start":1,"column_end":50,"is_primary":false,"text":[{"text":"pub fn message(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":50}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0119]\u001b[0m\u001b[0m\u001b[1m: conflicting implementations of trait `prost::Message` for type `EntityChange`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/pb/sf.substreams.v1.rs:10:28\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m8\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m#[derive(::prost::Message)]\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m----------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mfirst implementation here\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m9\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m#[allow(clippy::derive_partial_eq_without_eq)]\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m10\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m#[derive(Clone, PartialEq, ::prost::Message)]\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mconflicting implementation for `EntityChange`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the derive macro `::prost::Message` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"conflicting implementations of trait `prost::Message` for type `Field`","code":{"code":"E0119","explanation":"There are conflicting trait implementations for the same type.\n\nErroneous code example:\n\n```compile_fail,E0119\ntrait MyTrait {\n    fn get(&self) -> usize;\n}\n\nimpl<T> MyTrait for T {\n    fn get(&self) -> usize { 0 }\n}\n\nstruct Foo {\n    value: usize\n}\n\nimpl MyTrait for Foo { // error: conflicting implementations of trait\n                       //        `MyTrait` for type `Foo`\n    fn get(&self) -> usize { self.value }\n}\n```\n\nWhen looking for the implementation for the trait, the compiler finds\nboth the `impl<T> MyTrait for T` where T is all types and the `impl\nMyTrait for Foo`. Since a trait cannot be implemented multiple times,\nthis is an error. So, when you write:\n\n```\ntrait MyTrait {\n    fn get(&self) -> usize;\n}\n\nimpl<T> MyTrait for T {\n    fn get(&self) -> usize { 0 }\n}\n```\n\nThis makes the trait implemented on all types in the scope. So if you\ntry to implement it on another one after that, the implementations will\nconflict. Example:\n\n```\ntrait MyTrait {\n    fn get(&self) -> usize;\n}\n\nimpl<T> MyTrait for T {\n    fn get(&self) -> usize { 0 }\n}\n\nstruct Foo;\n\nfn main() {\n    let f = Foo;\n\n    f.get(); // the trait is implemented so we can use it\n}\n```\n"},"level":"error","spans":[{"file_name":"src/pb/sf.substreams.v1.rs","byte_start":736,"byte_end":752,"line_start":21,"line_end":21,"column_start":10,"column_end":26,"is_primary":false,"text":[{"text":"#[derive(::prost::Message)]","highlight_start":10,"highlight_end":26}],"label":"first implementation here","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/pb/sf.substreams.v1.rs","byte_start":736,"byte_end":752,"line_start":21,"line_end":21,"column_start":10,"column_end":26,"is_primary":false,"text":[{"text":"#[derive(::prost::Message)]","highlight_start":10,"highlight_end":26}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(::prost::Message)]","def_site_span":{"file_name":"/home/codespace/.cargo/registry/src/index.crates.io-6f17d22bba15001f/prost-derive-0.11.9/src/lib.rs","byte_start":7524,"byte_end":7573,"line_start":242,"line_end":242,"column_start":1,"column_end":50,"is_primary":false,"text":[{"text":"pub fn message(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":50}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/pb/sf.substreams.v1.rs","byte_start":829,"byte_end":845,"line_start":23,"line_end":23,"column_start":28,"column_end":44,"is_primary":true,"text":[{"text":"#[derive(Clone, PartialEq, ::prost::Message)]","highlight_start":28,"highlight_end":44}],"label":"conflicting implementation for `Field`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/pb/sf.substreams.v1.rs","byte_start":829,"byte_end":845,"line_start":23,"line_end":23,"column_start":28,"column_end":44,"is_primary":false,"text":[{"text":"#[derive(Clone, PartialEq, ::prost::Message)]","highlight_start":28,"highlight_end":44}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(::prost::Message)]","def_site_span":{"file_name":"/home/codespace/.cargo/registry/src/index.crates.io-6f17d22bba15001f/prost-derive-0.11.9/src/lib.rs","byte_start":7524,"byte_end":7573,"line_start":242,"line_end":242,"column_start":1,"column_end":50,"is_primary":false,"text":[{"text":"pub fn message(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":50}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0119]\u001b[0m\u001b[0m\u001b[1m: conflicting implementations of trait `prost::Message` for type `Field`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/pb/sf.substreams.v1.rs:23:28\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m21\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m#[derive(::prost::Message)]\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m----------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mfirst implementation here\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m22\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m#[allow(clippy::derive_partial_eq_without_eq)]\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m23\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m#[derive(Clone, PartialEq, ::prost::Message)]\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mconflicting implementation for `Field`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the derive macro `::prost::Message` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"conflicting implementations of trait `prost::Message` for type `Value`","code":{"code":"E0119","explanation":"There are conflicting trait implementations for the same type.\n\nErroneous code example:\n\n```compile_fail,E0119\ntrait MyTrait {\n    fn get(&self) -> usize;\n}\n\nimpl<T> MyTrait for T {\n    fn get(&self) -> usize { 0 }\n}\n\nstruct Foo {\n    value: usize\n}\n\nimpl MyTrait for Foo { // error: conflicting implementations of trait\n                       //        `MyTrait` for type `Foo`\n    fn get(&self) -> usize { self.value }\n}\n```\n\nWhen looking for the implementation for the trait, the compiler finds\nboth the `impl<T> MyTrait for T` where T is all types and the `impl\nMyTrait for Foo`. Since a trait cannot be implemented multiple times,\nthis is an error. So, when you write:\n\n```\ntrait MyTrait {\n    fn get(&self) -> usize;\n}\n\nimpl<T> MyTrait for T {\n    fn get(&self) -> usize { 0 }\n}\n```\n\nThis makes the trait implemented on all types in the scope. So if you\ntry to implement it on another one after that, the implementations will\nconflict. Example:\n\n```\ntrait MyTrait {\n    fn get(&self) -> usize;\n}\n\nimpl<T> MyTrait for T {\n    fn get(&self) -> usize { 0 }\n}\n\nstruct Foo;\n\nfn main() {\n    let f = Foo;\n\n    f.get(); // the trait is implemented so we can use it\n}\n```\n"},"level":"error","spans":[{"file_name":"src/pb/sf.substreams.v1.rs","byte_start":1045,"byte_end":1061,"line_start":30,"line_end":30,"column_start":10,"column_end":26,"is_primary":false,"text":[{"text":"#[derive(::prost::Message)]","highlight_start":10,"highlight_end":26}],"label":"first implementation here","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/pb/sf.substreams.v1.rs","byte_start":1045,"byte_end":1061,"line_start":30,"line_end":30,"column_start":10,"column_end":26,"is_primary":false,"text":[{"text":"#[derive(::prost::Message)]","highlight_start":10,"highlight_end":26}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(::prost::Message)]","def_site_span":{"file_name":"/home/codespace/.cargo/registry/src/index.crates.io-6f17d22bba15001f/prost-derive-0.11.9/src/lib.rs","byte_start":7524,"byte_end":7573,"line_start":242,"line_end":242,"column_start":1,"column_end":50,"is_primary":false,"text":[{"text":"pub fn message(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":50}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/pb/sf.substreams.v1.rs","byte_start":1138,"byte_end":1154,"line_start":32,"line_end":32,"column_start":28,"column_end":44,"is_primary":true,"text":[{"text":"#[derive(Clone, PartialEq, ::prost::Message)]","highlight_start":28,"highlight_end":44}],"label":"conflicting implementation for `Value`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/pb/sf.substreams.v1.rs","byte_start":1138,"byte_end":1154,"line_start":32,"line_end":32,"column_start":28,"column_end":44,"is_primary":false,"text":[{"text":"#[derive(Clone, PartialEq, ::prost::Message)]","highlight_start":28,"highlight_end":44}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(::prost::Message)]","def_site_span":{"file_name":"/home/codespace/.cargo/registry/src/index.crates.io-6f17d22bba15001f/prost-derive-0.11.9/src/lib.rs","byte_start":7524,"byte_end":7573,"line_start":242,"line_end":242,"column_start":1,"column_end":50,"is_primary":false,"text":[{"text":"pub fn message(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":50}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0119]\u001b[0m\u001b[0m\u001b[1m: conflicting implementations of trait `prost::Message` for type `Value`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/pb/sf.substreams.v1.rs:32:28\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m30\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m#[derive(::prost::Message)]\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m----------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mfirst implementation here\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m31\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m#[allow(clippy::derive_partial_eq_without_eq)]\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m32\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m#[derive(Clone, PartialEq, ::prost::Message)]\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mconflicting implementation for `Value`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the derive macro `::prost::Message` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"conflicting implementations of trait `prost::Message` for type `Array`","code":{"code":"E0119","explanation":"There are conflicting trait implementations for the same type.\n\nErroneous code example:\n\n```compile_fail,E0119\ntrait MyTrait {\n    fn get(&self) -> usize;\n}\n\nimpl<T> MyTrait for T {\n    fn get(&self) -> usize { 0 }\n}\n\nstruct Foo {\n    value: usize\n}\n\nimpl MyTrait for Foo { // error: conflicting implementations of trait\n                       //        `MyTrait` for type `Foo`\n    fn get(&self) -> usize { self.value }\n}\n```\n\nWhen looking for the implementation for the trait, the compiler finds\nboth the `impl<T> MyTrait for T` where T is all types and the `impl\nMyTrait for Foo`. Since a trait cannot be implemented multiple times,\nthis is an error. So, when you write:\n\n```\ntrait MyTrait {\n    fn get(&self) -> usize;\n}\n\nimpl<T> MyTrait for T {\n    fn get(&self) -> usize { 0 }\n}\n```\n\nThis makes the trait implemented on all types in the scope. So if you\ntry to implement it on another one after that, the implementations will\nconflict. Example:\n\n```\ntrait MyTrait {\n    fn get(&self) -> usize;\n}\n\nimpl<T> MyTrait for T {\n    fn get(&self) -> usize { 0 }\n}\n\nstruct Foo;\n\nfn main() {\n    let f = Foo;\n\n    f.get(); // the trait is implemented so we can use it\n}\n```\n"},"level":"error","spans":[{"file_name":"src/pb/sf.substreams.v1.rs","byte_start":1967,"byte_end":1983,"line_start":57,"line_end":57,"column_start":10,"column_end":26,"is_primary":false,"text":[{"text":"#[derive(::prost::Message)]","highlight_start":10,"highlight_end":26}],"label":"first implementation here","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/pb/sf.substreams.v1.rs","byte_start":1967,"byte_end":1983,"line_start":57,"line_end":57,"column_start":10,"column_end":26,"is_primary":false,"text":[{"text":"#[derive(::prost::Message)]","highlight_start":10,"highlight_end":26}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(::prost::Message)]","def_site_span":{"file_name":"/home/codespace/.cargo/registry/src/index.crates.io-6f17d22bba15001f/prost-derive-0.11.9/src/lib.rs","byte_start":7524,"byte_end":7573,"line_start":242,"line_end":242,"column_start":1,"column_end":50,"is_primary":false,"text":[{"text":"pub fn message(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":50}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/pb/sf.substreams.v1.rs","byte_start":2060,"byte_end":2076,"line_start":59,"line_end":59,"column_start":28,"column_end":44,"is_primary":true,"text":[{"text":"#[derive(Clone, PartialEq, ::prost::Message)]","highlight_start":28,"highlight_end":44}],"label":"conflicting implementation for `Array`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/pb/sf.substreams.v1.rs","byte_start":2060,"byte_end":2076,"line_start":59,"line_end":59,"column_start":28,"column_end":44,"is_primary":false,"text":[{"text":"#[derive(Clone, PartialEq, ::prost::Message)]","highlight_start":28,"highlight_end":44}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(::prost::Message)]","def_site_span":{"file_name":"/home/codespace/.cargo/registry/src/index.crates.io-6f17d22bba15001f/prost-derive-0.11.9/src/lib.rs","byte_start":7524,"byte_end":7573,"line_start":242,"line_end":242,"column_start":1,"column_end":50,"is_primary":false,"text":[{"text":"pub fn message(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":50}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0119]\u001b[0m\u001b[0m\u001b[1m: conflicting implementations of trait `prost::Message` for type `Array`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/pb/sf.substreams.v1.rs:59:28\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m57\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m#[derive(::prost::Message)]\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m----------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mfirst implementation here\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m58\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m#[allow(clippy::derive_partial_eq_without_eq)]\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m59\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m#[derive(Clone, PartialEq, ::prost::Message)]\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mconflicting implementation for `Array`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the derive macro `::prost::Message` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"conflicting implementations of trait `Default` for type `EntityChanges`","code":{"code":"E0119","explanation":"There are conflicting trait implementations for the same type.\n\nErroneous code example:\n\n```compile_fail,E0119\ntrait MyTrait {\n    fn get(&self) -> usize;\n}\n\nimpl<T> MyTrait for T {\n    fn get(&self) -> usize { 0 }\n}\n\nstruct Foo {\n    value: usize\n}\n\nimpl MyTrait for Foo { // error: conflicting implementations of trait\n                       //        `MyTrait` for type `Foo`\n    fn get(&self) -> usize { self.value }\n}\n```\n\nWhen looking for the implementation for the trait, the compiler finds\nboth the `impl<T> MyTrait for T` where T is all types and the `impl\nMyTrait for Foo`. Since a trait cannot be implemented multiple times,\nthis is an error. So, when you write:\n\n```\ntrait MyTrait {\n    fn get(&self) -> usize;\n}\n\nimpl<T> MyTrait for T {\n    fn get(&self) -> usize { 0 }\n}\n```\n\nThis makes the trait implemented on all types in the scope. So if you\ntry to implement it on another one after that, the implementations will\nconflict. Example:\n\n```\ntrait MyTrait {\n    fn get(&self) -> usize;\n}\n\nimpl<T> MyTrait for T {\n    fn get(&self) -> usize { 0 }\n}\n\nstruct Foo;\n\nfn main() {\n    let f = Foo;\n\n    f.get(); // the trait is implemented so we can use it\n}\n```\n"},"level":"error","spans":[{"file_name":"src/pb/sf.substreams.v1.rs","byte_start":9,"byte_end":25,"line_start":1,"line_end":1,"column_start":10,"column_end":26,"is_primary":false,"text":[{"text":"#[derive(::prost::Message)]","highlight_start":10,"highlight_end":26}],"label":"first implementation here","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/pb/sf.substreams.v1.rs","byte_start":9,"byte_end":25,"line_start":1,"line_end":1,"column_start":10,"column_end":26,"is_primary":false,"text":[{"text":"#[derive(::prost::Message)]","highlight_start":10,"highlight_end":26}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(::prost::Message)]","def_site_span":{"file_name":"/home/codespace/.cargo/registry/src/index.crates.io-6f17d22bba15001f/prost-derive-0.11.9/src/lib.rs","byte_start":7524,"byte_end":7573,"line_start":242,"line_end":242,"column_start":1,"column_end":50,"is_primary":false,"text":[{"text":"pub fn message(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":50}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/pb/sf.substreams.v1.rs","byte_start":102,"byte_end":118,"line_start":3,"line_end":3,"column_start":28,"column_end":44,"is_primary":true,"text":[{"text":"#[derive(Clone, PartialEq, ::prost::Message)]","highlight_start":28,"highlight_end":44}],"label":"conflicting implementation for `EntityChanges`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/pb/sf.substreams.v1.rs","byte_start":102,"byte_end":118,"line_start":3,"line_end":3,"column_start":28,"column_end":44,"is_primary":false,"text":[{"text":"#[derive(Clone, PartialEq, ::prost::Message)]","highlight_start":28,"highlight_end":44}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(::prost::Message)]","def_site_span":{"file_name":"/home/codespace/.cargo/registry/src/index.crates.io-6f17d22bba15001f/prost-derive-0.11.9/src/lib.rs","byte_start":7524,"byte_end":7573,"line_start":242,"line_end":242,"column_start":1,"column_end":50,"is_primary":false,"text":[{"text":"pub fn message(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":50}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0119]\u001b[0m\u001b[0m\u001b[1m: conflicting implementations of trait `Default` for type `EntityChanges`\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/pb/sf.substreams.v1.rs:3:28\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m#[derive(::prost::Message)]\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m----------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mfirst implementation here\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m#[allow(clippy::derive_partial_eq_without_eq)]\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m#[derive(Clone, PartialEq, ::prost::Message)]\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mconflicting implementation for `EntityChanges`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the derive macro `::prost::Message` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"conflicting implementations of trait `Default` for type `EntityChange`","code":{"code":"E0119","explanation":"There are conflicting trait implementations for the same type.\n\nErroneous code example:\n\n```compile_fail,E0119\ntrait MyTrait {\n    fn get(&self) -> usize;\n}\n\nimpl<T> MyTrait for T {\n    fn get(&self) -> usize { 0 }\n}\n\nstruct Foo {\n    value: usize\n}\n\nimpl MyTrait for Foo { // error: conflicting implementations of trait\n                       //        `MyTrait` for type `Foo`\n    fn get(&self) -> usize { self.value }\n}\n```\n\nWhen looking for the implementation for the trait, the compiler finds\nboth the `impl<T> MyTrait for T` where T is all types and the `impl\nMyTrait for Foo`. Since a trait cannot be implemented multiple times,\nthis is an error. So, when you write:\n\n```\ntrait MyTrait {\n    fn get(&self) -> usize;\n}\n\nimpl<T> MyTrait for T {\n    fn get(&self) -> usize { 0 }\n}\n```\n\nThis makes the trait implemented on all types in the scope. So if you\ntry to implement it on another one after that, the implementations will\nconflict. Example:\n\n```\ntrait MyTrait {\n    fn get(&self) -> usize;\n}\n\nimpl<T> MyTrait for T {\n    fn get(&self) -> usize { 0 }\n}\n\nstruct Foo;\n\nfn main() {\n    let f = Foo;\n\n    f.get(); // the trait is implemented so we can use it\n}\n```\n"},"level":"error","spans":[{"file_name":"src/pb/sf.substreams.v1.rs","byte_start":259,"byte_end":275,"line_start":8,"line_end":8,"column_start":10,"column_end":26,"is_primary":false,"text":[{"text":"#[derive(::prost::Message)]","highlight_start":10,"highlight_end":26}],"label":"first implementation here","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/pb/sf.substreams.v1.rs","byte_start":259,"byte_end":275,"line_start":8,"line_end":8,"column_start":10,"column_end":26,"is_primary":false,"text":[{"text":"#[derive(::prost::Message)]","highlight_start":10,"highlight_end":26}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(::prost::Message)]","def_site_span":{"file_name":"/home/codespace/.cargo/registry/src/index.crates.io-6f17d22bba15001f/prost-derive-0.11.9/src/lib.rs","byte_start":7524,"byte_end":7573,"line_start":242,"line_end":242,"column_start":1,"column_end":50,"is_primary":false,"text":[{"text":"pub fn message(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":50}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/pb/sf.substreams.v1.rs","byte_start":352,"byte_end":368,"line_start":10,"line_end":10,"column_start":28,"column_end":44,"is_primary":true,"text":[{"text":"#[derive(Clone, PartialEq, ::prost::Message)]","highlight_start":28,"highlight_end":44}],"label":"conflicting implementation for `EntityChange`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/pb/sf.substreams.v1.rs","byte_start":352,"byte_end":368,"line_start":10,"line_end":10,"column_start":28,"column_end":44,"is_primary":false,"text":[{"text":"#[derive(Clone, PartialEq, ::prost::Message)]","highlight_start":28,"highlight_end":44}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(::prost::Message)]","def_site_span":{"file_name":"/home/codespace/.cargo/registry/src/index.crates.io-6f17d22bba15001f/prost-derive-0.11.9/src/lib.rs","byte_start":7524,"byte_end":7573,"line_start":242,"line_end":242,"column_start":1,"column_end":50,"is_primary":false,"text":[{"text":"pub fn message(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":50}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0119]\u001b[0m\u001b[0m\u001b[1m: conflicting implementations of trait `Default` for type `EntityChange`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/pb/sf.substreams.v1.rs:10:28\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m8\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m#[derive(::prost::Message)]\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m----------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mfirst implementation here\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m9\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m#[allow(clippy::derive_partial_eq_without_eq)]\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m10\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m#[derive(Clone, PartialEq, ::prost::Message)]\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mconflicting implementation for `EntityChange`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the derive macro `::prost::Message` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"conflicting implementations of trait `Default` for type `Field`","code":{"code":"E0119","explanation":"There are conflicting trait implementations for the same type.\n\nErroneous code example:\n\n```compile_fail,E0119\ntrait MyTrait {\n    fn get(&self) -> usize;\n}\n\nimpl<T> MyTrait for T {\n    fn get(&self) -> usize { 0 }\n}\n\nstruct Foo {\n    value: usize\n}\n\nimpl MyTrait for Foo { // error: conflicting implementations of trait\n                       //        `MyTrait` for type `Foo`\n    fn get(&self) -> usize { self.value }\n}\n```\n\nWhen looking for the implementation for the trait, the compiler finds\nboth the `impl<T> MyTrait for T` where T is all types and the `impl\nMyTrait for Foo`. Since a trait cannot be implemented multiple times,\nthis is an error. So, when you write:\n\n```\ntrait MyTrait {\n    fn get(&self) -> usize;\n}\n\nimpl<T> MyTrait for T {\n    fn get(&self) -> usize { 0 }\n}\n```\n\nThis makes the trait implemented on all types in the scope. So if you\ntry to implement it on another one after that, the implementations will\nconflict. Example:\n\n```\ntrait MyTrait {\n    fn get(&self) -> usize;\n}\n\nimpl<T> MyTrait for T {\n    fn get(&self) -> usize { 0 }\n}\n\nstruct Foo;\n\nfn main() {\n    let f = Foo;\n\n    f.get(); // the trait is implemented so we can use it\n}\n```\n"},"level":"error","spans":[{"file_name":"src/pb/sf.substreams.v1.rs","byte_start":736,"byte_end":752,"line_start":21,"line_end":21,"column_start":10,"column_end":26,"is_primary":false,"text":[{"text":"#[derive(::prost::Message)]","highlight_start":10,"highlight_end":26}],"label":"first implementation here","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/pb/sf.substreams.v1.rs","byte_start":736,"byte_end":752,"line_start":21,"line_end":21,"column_start":10,"column_end":26,"is_primary":false,"text":[{"text":"#[derive(::prost::Message)]","highlight_start":10,"highlight_end":26}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(::prost::Message)]","def_site_span":{"file_name":"/home/codespace/.cargo/registry/src/index.crates.io-6f17d22bba15001f/prost-derive-0.11.9/src/lib.rs","byte_start":7524,"byte_end":7573,"line_start":242,"line_end":242,"column_start":1,"column_end":50,"is_primary":false,"text":[{"text":"pub fn message(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":50}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/pb/sf.substreams.v1.rs","byte_start":829,"byte_end":845,"line_start":23,"line_end":23,"column_start":28,"column_end":44,"is_primary":true,"text":[{"text":"#[derive(Clone, PartialEq, ::prost::Message)]","highlight_start":28,"highlight_end":44}],"label":"conflicting implementation for `Field`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/pb/sf.substreams.v1.rs","byte_start":829,"byte_end":845,"line_start":23,"line_end":23,"column_start":28,"column_end":44,"is_primary":false,"text":[{"text":"#[derive(Clone, PartialEq, ::prost::Message)]","highlight_start":28,"highlight_end":44}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(::prost::Message)]","def_site_span":{"file_name":"/home/codespace/.cargo/registry/src/index.crates.io-6f17d22bba15001f/prost-derive-0.11.9/src/lib.rs","byte_start":7524,"byte_end":7573,"line_start":242,"line_end":242,"column_start":1,"column_end":50,"is_primary":false,"text":[{"text":"pub fn message(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":50}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0119]\u001b[0m\u001b[0m\u001b[1m: conflicting implementations of trait `Default` for type `Field`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/pb/sf.substreams.v1.rs:23:28\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m21\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m#[derive(::prost::Message)]\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m----------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mfirst implementation here\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m22\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m#[allow(clippy::derive_partial_eq_without_eq)]\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m23\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m#[derive(Clone, PartialEq, ::prost::Message)]\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mconflicting implementation for `Field`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the derive macro `::prost::Message` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"conflicting implementations of trait `Default` for type `Value`","code":{"code":"E0119","explanation":"There are conflicting trait implementations for the same type.\n\nErroneous code example:\n\n```compile_fail,E0119\ntrait MyTrait {\n    fn get(&self) -> usize;\n}\n\nimpl<T> MyTrait for T {\n    fn get(&self) -> usize { 0 }\n}\n\nstruct Foo {\n    value: usize\n}\n\nimpl MyTrait for Foo { // error: conflicting implementations of trait\n                       //        `MyTrait` for type `Foo`\n    fn get(&self) -> usize { self.value }\n}\n```\n\nWhen looking for the implementation for the trait, the compiler finds\nboth the `impl<T> MyTrait for T` where T is all types and the `impl\nMyTrait for Foo`. Since a trait cannot be implemented multiple times,\nthis is an error. So, when you write:\n\n```\ntrait MyTrait {\n    fn get(&self) -> usize;\n}\n\nimpl<T> MyTrait for T {\n    fn get(&self) -> usize { 0 }\n}\n```\n\nThis makes the trait implemented on all types in the scope. So if you\ntry to implement it on another one after that, the implementations will\nconflict. Example:\n\n```\ntrait MyTrait {\n    fn get(&self) -> usize;\n}\n\nimpl<T> MyTrait for T {\n    fn get(&self) -> usize { 0 }\n}\n\nstruct Foo;\n\nfn main() {\n    let f = Foo;\n\n    f.get(); // the trait is implemented so we can use it\n}\n```\n"},"level":"error","spans":[{"file_name":"src/pb/sf.substreams.v1.rs","byte_start":1045,"byte_end":1061,"line_start":30,"line_end":30,"column_start":10,"column_end":26,"is_primary":false,"text":[{"text":"#[derive(::prost::Message)]","highlight_start":10,"highlight_end":26}],"label":"first implementation here","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/pb/sf.substreams.v1.rs","byte_start":1045,"byte_end":1061,"line_start":30,"line_end":30,"column_start":10,"column_end":26,"is_primary":false,"text":[{"text":"#[derive(::prost::Message)]","highlight_start":10,"highlight_end":26}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(::prost::Message)]","def_site_span":{"file_name":"/home/codespace/.cargo/registry/src/index.crates.io-6f17d22bba15001f/prost-derive-0.11.9/src/lib.rs","byte_start":7524,"byte_end":7573,"line_start":242,"line_end":242,"column_start":1,"column_end":50,"is_primary":false,"text":[{"text":"pub fn message(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":50}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/pb/sf.substreams.v1.rs","byte_start":1138,"byte_end":1154,"line_start":32,"line_end":32,"column_start":28,"column_end":44,"is_primary":true,"text":[{"text":"#[derive(Clone, PartialEq, ::prost::Message)]","highlight_start":28,"highlight_end":44}],"label":"conflicting implementation for `Value`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/pb/sf.substreams.v1.rs","byte_start":1138,"byte_end":1154,"line_start":32,"line_end":32,"column_start":28,"column_end":44,"is_primary":false,"text":[{"text":"#[derive(Clone, PartialEq, ::prost::Message)]","highlight_start":28,"highlight_end":44}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(::prost::Message)]","def_site_span":{"file_name":"/home/codespace/.cargo/registry/src/index.crates.io-6f17d22bba15001f/prost-derive-0.11.9/src/lib.rs","byte_start":7524,"byte_end":7573,"line_start":242,"line_end":242,"column_start":1,"column_end":50,"is_primary":false,"text":[{"text":"pub fn message(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":50}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0119]\u001b[0m\u001b[0m\u001b[1m: conflicting implementations of trait `Default` for type `Value`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/pb/sf.substreams.v1.rs:32:28\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m30\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m#[derive(::prost::Message)]\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m----------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mfirst implementation here\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m31\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m#[allow(clippy::derive_partial_eq_without_eq)]\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m32\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m#[derive(Clone, PartialEq, ::prost::Message)]\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mconflicting implementation for `Value`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the derive macro `::prost::Message` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"conflicting implementations of trait `Default` for type `Array`","code":{"code":"E0119","explanation":"There are conflicting trait implementations for the same type.\n\nErroneous code example:\n\n```compile_fail,E0119\ntrait MyTrait {\n    fn get(&self) -> usize;\n}\n\nimpl<T> MyTrait for T {\n    fn get(&self) -> usize { 0 }\n}\n\nstruct Foo {\n    value: usize\n}\n\nimpl MyTrait for Foo { // error: conflicting implementations of trait\n                       //        `MyTrait` for type `Foo`\n    fn get(&self) -> usize { self.value }\n}\n```\n\nWhen looking for the implementation for the trait, the compiler finds\nboth the `impl<T> MyTrait for T` where T is all types and the `impl\nMyTrait for Foo`. Since a trait cannot be implemented multiple times,\nthis is an error. So, when you write:\n\n```\ntrait MyTrait {\n    fn get(&self) -> usize;\n}\n\nimpl<T> MyTrait for T {\n    fn get(&self) -> usize { 0 }\n}\n```\n\nThis makes the trait implemented on all types in the scope. So if you\ntry to implement it on another one after that, the implementations will\nconflict. Example:\n\n```\ntrait MyTrait {\n    fn get(&self) -> usize;\n}\n\nimpl<T> MyTrait for T {\n    fn get(&self) -> usize { 0 }\n}\n\nstruct Foo;\n\nfn main() {\n    let f = Foo;\n\n    f.get(); // the trait is implemented so we can use it\n}\n```\n"},"level":"error","spans":[{"file_name":"src/pb/sf.substreams.v1.rs","byte_start":1967,"byte_end":1983,"line_start":57,"line_end":57,"column_start":10,"column_end":26,"is_primary":false,"text":[{"text":"#[derive(::prost::Message)]","highlight_start":10,"highlight_end":26}],"label":"first implementation here","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/pb/sf.substreams.v1.rs","byte_start":1967,"byte_end":1983,"line_start":57,"line_end":57,"column_start":10,"column_end":26,"is_primary":false,"text":[{"text":"#[derive(::prost::Message)]","highlight_start":10,"highlight_end":26}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(::prost::Message)]","def_site_span":{"file_name":"/home/codespace/.cargo/registry/src/index.crates.io-6f17d22bba15001f/prost-derive-0.11.9/src/lib.rs","byte_start":7524,"byte_end":7573,"line_start":242,"line_end":242,"column_start":1,"column_end":50,"is_primary":false,"text":[{"text":"pub fn message(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":50}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/pb/sf.substreams.v1.rs","byte_start":2060,"byte_end":2076,"line_start":59,"line_end":59,"column_start":28,"column_end":44,"is_primary":true,"text":[{"text":"#[derive(Clone, PartialEq, ::prost::Message)]","highlight_start":28,"highlight_end":44}],"label":"conflicting implementation for `Array`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/pb/sf.substreams.v1.rs","byte_start":2060,"byte_end":2076,"line_start":59,"line_end":59,"column_start":28,"column_end":44,"is_primary":false,"text":[{"text":"#[derive(Clone, PartialEq, ::prost::Message)]","highlight_start":28,"highlight_end":44}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(::prost::Message)]","def_site_span":{"file_name":"/home/codespace/.cargo/registry/src/index.crates.io-6f17d22bba15001f/prost-derive-0.11.9/src/lib.rs","byte_start":7524,"byte_end":7573,"line_start":242,"line_end":242,"column_start":1,"column_end":50,"is_primary":false,"text":[{"text":"pub fn message(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":50}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0119]\u001b[0m\u001b[0m\u001b[1m: conflicting implementations of trait `Default` for type `Array`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/pb/sf.substreams.v1.rs:59:28\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m57\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m#[derive(::prost::Message)]\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m----------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mfirst implementation here\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m58\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m#[allow(clippy::derive_partial_eq_without_eq)]\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m59\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m#[derive(Clone, PartialEq, ::prost::Message)]\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mconflicting implementation for `Array`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the derive macro `::prost::Message` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"conflicting implementations of trait `Debug` for type `EntityChanges`","code":{"code":"E0119","explanation":"There are conflicting trait implementations for the same type.\n\nErroneous code example:\n\n```compile_fail,E0119\ntrait MyTrait {\n    fn get(&self) -> usize;\n}\n\nimpl<T> MyTrait for T {\n    fn get(&self) -> usize { 0 }\n}\n\nstruct Foo {\n    value: usize\n}\n\nimpl MyTrait for Foo { // error: conflicting implementations of trait\n                       //        `MyTrait` for type `Foo`\n    fn get(&self) -> usize { self.value }\n}\n```\n\nWhen looking for the implementation for the trait, the compiler finds\nboth the `impl<T> MyTrait for T` where T is all types and the `impl\nMyTrait for Foo`. Since a trait cannot be implemented multiple times,\nthis is an error. So, when you write:\n\n```\ntrait MyTrait {\n    fn get(&self) -> usize;\n}\n\nimpl<T> MyTrait for T {\n    fn get(&self) -> usize { 0 }\n}\n```\n\nThis makes the trait implemented on all types in the scope. So if you\ntry to implement it on another one after that, the implementations will\nconflict. Example:\n\n```\ntrait MyTrait {\n    fn get(&self) -> usize;\n}\n\nimpl<T> MyTrait for T {\n    fn get(&self) -> usize { 0 }\n}\n\nstruct Foo;\n\nfn main() {\n    let f = Foo;\n\n    f.get(); // the trait is implemented so we can use it\n}\n```\n"},"level":"error","spans":[{"file_name":"src/pb/sf.substreams.v1.rs","byte_start":9,"byte_end":25,"line_start":1,"line_end":1,"column_start":10,"column_end":26,"is_primary":false,"text":[{"text":"#[derive(::prost::Message)]","highlight_start":10,"highlight_end":26}],"label":"first implementation here","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/pb/sf.substreams.v1.rs","byte_start":9,"byte_end":25,"line_start":1,"line_end":1,"column_start":10,"column_end":26,"is_primary":false,"text":[{"text":"#[derive(::prost::Message)]","highlight_start":10,"highlight_end":26}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(::prost::Message)]","def_site_span":{"file_name":"/home/codespace/.cargo/registry/src/index.crates.io-6f17d22bba15001f/prost-derive-0.11.9/src/lib.rs","byte_start":7524,"byte_end":7573,"line_start":242,"line_end":242,"column_start":1,"column_end":50,"is_primary":false,"text":[{"text":"pub fn message(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":50}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/pb/sf.substreams.v1.rs","byte_start":102,"byte_end":118,"line_start":3,"line_end":3,"column_start":28,"column_end":44,"is_primary":true,"text":[{"text":"#[derive(Clone, PartialEq, ::prost::Message)]","highlight_start":28,"highlight_end":44}],"label":"conflicting implementation for `EntityChanges`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/pb/sf.substreams.v1.rs","byte_start":102,"byte_end":118,"line_start":3,"line_end":3,"column_start":28,"column_end":44,"is_primary":false,"text":[{"text":"#[derive(Clone, PartialEq, ::prost::Message)]","highlight_start":28,"highlight_end":44}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(::prost::Message)]","def_site_span":{"file_name":"/home/codespace/.cargo/registry/src/index.crates.io-6f17d22bba15001f/prost-derive-0.11.9/src/lib.rs","byte_start":7524,"byte_end":7573,"line_start":242,"line_end":242,"column_start":1,"column_end":50,"is_primary":false,"text":[{"text":"pub fn message(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":50}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0119]\u001b[0m\u001b[0m\u001b[1m: conflicting implementations of trait `Debug` for type `EntityChanges`\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/pb/sf.substreams.v1.rs:3:28\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m#[derive(::prost::Message)]\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m----------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mfirst implementation here\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m#[allow(clippy::derive_partial_eq_without_eq)]\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m#[derive(Clone, PartialEq, ::prost::Message)]\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mconflicting implementation for `EntityChanges`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the derive macro `::prost::Message` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"conflicting implementations of trait `Debug` for type `EntityChange`","code":{"code":"E0119","explanation":"There are conflicting trait implementations for the same type.\n\nErroneous code example:\n\n```compile_fail,E0119\ntrait MyTrait {\n    fn get(&self) -> usize;\n}\n\nimpl<T> MyTrait for T {\n    fn get(&self) -> usize { 0 }\n}\n\nstruct Foo {\n    value: usize\n}\n\nimpl MyTrait for Foo { // error: conflicting implementations of trait\n                       //        `MyTrait` for type `Foo`\n    fn get(&self) -> usize { self.value }\n}\n```\n\nWhen looking for the implementation for the trait, the compiler finds\nboth the `impl<T> MyTrait for T` where T is all types and the `impl\nMyTrait for Foo`. Since a trait cannot be implemented multiple times,\nthis is an error. So, when you write:\n\n```\ntrait MyTrait {\n    fn get(&self) -> usize;\n}\n\nimpl<T> MyTrait for T {\n    fn get(&self) -> usize { 0 }\n}\n```\n\nThis makes the trait implemented on all types in the scope. So if you\ntry to implement it on another one after that, the implementations will\nconflict. Example:\n\n```\ntrait MyTrait {\n    fn get(&self) -> usize;\n}\n\nimpl<T> MyTrait for T {\n    fn get(&self) -> usize { 0 }\n}\n\nstruct Foo;\n\nfn main() {\n    let f = Foo;\n\n    f.get(); // the trait is implemented so we can use it\n}\n```\n"},"level":"error","spans":[{"file_name":"src/pb/sf.substreams.v1.rs","byte_start":259,"byte_end":275,"line_start":8,"line_end":8,"column_start":10,"column_end":26,"is_primary":false,"text":[{"text":"#[derive(::prost::Message)]","highlight_start":10,"highlight_end":26}],"label":"first implementation here","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/pb/sf.substreams.v1.rs","byte_start":259,"byte_end":275,"line_start":8,"line_end":8,"column_start":10,"column_end":26,"is_primary":false,"text":[{"text":"#[derive(::prost::Message)]","highlight_start":10,"highlight_end":26}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(::prost::Message)]","def_site_span":{"file_name":"/home/codespace/.cargo/registry/src/index.crates.io-6f17d22bba15001f/prost-derive-0.11.9/src/lib.rs","byte_start":7524,"byte_end":7573,"line_start":242,"line_end":242,"column_start":1,"column_end":50,"is_primary":false,"text":[{"text":"pub fn message(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":50}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/pb/sf.substreams.v1.rs","byte_start":352,"byte_end":368,"line_start":10,"line_end":10,"column_start":28,"column_end":44,"is_primary":true,"text":[{"text":"#[derive(Clone, PartialEq, ::prost::Message)]","highlight_start":28,"highlight_end":44}],"label":"conflicting implementation for `EntityChange`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/pb/sf.substreams.v1.rs","byte_start":352,"byte_end":368,"line_start":10,"line_end":10,"column_start":28,"column_end":44,"is_primary":false,"text":[{"text":"#[derive(Clone, PartialEq, ::prost::Message)]","highlight_start":28,"highlight_end":44}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(::prost::Message)]","def_site_span":{"file_name":"/home/codespace/.cargo/registry/src/index.crates.io-6f17d22bba15001f/prost-derive-0.11.9/src/lib.rs","byte_start":7524,"byte_end":7573,"line_start":242,"line_end":242,"column_start":1,"column_end":50,"is_primary":false,"text":[{"text":"pub fn message(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":50}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0119]\u001b[0m\u001b[0m\u001b[1m: conflicting implementations of trait `Debug` for type `EntityChange`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/pb/sf.substreams.v1.rs:10:28\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m8\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m#[derive(::prost::Message)]\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m----------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mfirst implementation here\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m9\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m#[allow(clippy::derive_partial_eq_without_eq)]\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m10\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m#[derive(Clone, PartialEq, ::prost::Message)]\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mconflicting implementation for `EntityChange`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the derive macro `::prost::Message` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"conflicting implementations of trait `Debug` for type `Field`","code":{"code":"E0119","explanation":"There are conflicting trait implementations for the same type.\n\nErroneous code example:\n\n```compile_fail,E0119\ntrait MyTrait {\n    fn get(&self) -> usize;\n}\n\nimpl<T> MyTrait for T {\n    fn get(&self) -> usize { 0 }\n}\n\nstruct Foo {\n    value: usize\n}\n\nimpl MyTrait for Foo { // error: conflicting implementations of trait\n                       //        `MyTrait` for type `Foo`\n    fn get(&self) -> usize { self.value }\n}\n```\n\nWhen looking for the implementation for the trait, the compiler finds\nboth the `impl<T> MyTrait for T` where T is all types and the `impl\nMyTrait for Foo`. Since a trait cannot be implemented multiple times,\nthis is an error. So, when you write:\n\n```\ntrait MyTrait {\n    fn get(&self) -> usize;\n}\n\nimpl<T> MyTrait for T {\n    fn get(&self) -> usize { 0 }\n}\n```\n\nThis makes the trait implemented on all types in the scope. So if you\ntry to implement it on another one after that, the implementations will\nconflict. Example:\n\n```\ntrait MyTrait {\n    fn get(&self) -> usize;\n}\n\nimpl<T> MyTrait for T {\n    fn get(&self) -> usize { 0 }\n}\n\nstruct Foo;\n\nfn main() {\n    let f = Foo;\n\n    f.get(); // the trait is implemented so we can use it\n}\n```\n"},"level":"error","spans":[{"file_name":"src/pb/sf.substreams.v1.rs","byte_start":736,"byte_end":752,"line_start":21,"line_end":21,"column_start":10,"column_end":26,"is_primary":false,"text":[{"text":"#[derive(::prost::Message)]","highlight_start":10,"highlight_end":26}],"label":"first implementation here","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/pb/sf.substreams.v1.rs","byte_start":736,"byte_end":752,"line_start":21,"line_end":21,"column_start":10,"column_end":26,"is_primary":false,"text":[{"text":"#[derive(::prost::Message)]","highlight_start":10,"highlight_end":26}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(::prost::Message)]","def_site_span":{"file_name":"/home/codespace/.cargo/registry/src/index.crates.io-6f17d22bba15001f/prost-derive-0.11.9/src/lib.rs","byte_start":7524,"byte_end":7573,"line_start":242,"line_end":242,"column_start":1,"column_end":50,"is_primary":false,"text":[{"text":"pub fn message(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":50}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/pb/sf.substreams.v1.rs","byte_start":829,"byte_end":845,"line_start":23,"line_end":23,"column_start":28,"column_end":44,"is_primary":true,"text":[{"text":"#[derive(Clone, PartialEq, ::prost::Message)]","highlight_start":28,"highlight_end":44}],"label":"conflicting implementation for `Field`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/pb/sf.substreams.v1.rs","byte_start":829,"byte_end":845,"line_start":23,"line_end":23,"column_start":28,"column_end":44,"is_primary":false,"text":[{"text":"#[derive(Clone, PartialEq, ::prost::Message)]","highlight_start":28,"highlight_end":44}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(::prost::Message)]","def_site_span":{"file_name":"/home/codespace/.cargo/registry/src/index.crates.io-6f17d22bba15001f/prost-derive-0.11.9/src/lib.rs","byte_start":7524,"byte_end":7573,"line_start":242,"line_end":242,"column_start":1,"column_end":50,"is_primary":false,"text":[{"text":"pub fn message(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":50}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0119]\u001b[0m\u001b[0m\u001b[1m: conflicting implementations of trait `Debug` for type `Field`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/pb/sf.substreams.v1.rs:23:28\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m21\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m#[derive(::prost::Message)]\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m----------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mfirst implementation here\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m22\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m#[allow(clippy::derive_partial_eq_without_eq)]\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m23\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m#[derive(Clone, PartialEq, ::prost::Message)]\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mconflicting implementation for `Field`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the derive macro `::prost::Message` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"conflicting implementations of trait `Debug` for type `Value`","code":{"code":"E0119","explanation":"There are conflicting trait implementations for the same type.\n\nErroneous code example:\n\n```compile_fail,E0119\ntrait MyTrait {\n    fn get(&self) -> usize;\n}\n\nimpl<T> MyTrait for T {\n    fn get(&self) -> usize { 0 }\n}\n\nstruct Foo {\n    value: usize\n}\n\nimpl MyTrait for Foo { // error: conflicting implementations of trait\n                       //        `MyTrait` for type `Foo`\n    fn get(&self) -> usize { self.value }\n}\n```\n\nWhen looking for the implementation for the trait, the compiler finds\nboth the `impl<T> MyTrait for T` where T is all types and the `impl\nMyTrait for Foo`. Since a trait cannot be implemented multiple times,\nthis is an error. So, when you write:\n\n```\ntrait MyTrait {\n    fn get(&self) -> usize;\n}\n\nimpl<T> MyTrait for T {\n    fn get(&self) -> usize { 0 }\n}\n```\n\nThis makes the trait implemented on all types in the scope. So if you\ntry to implement it on another one after that, the implementations will\nconflict. Example:\n\n```\ntrait MyTrait {\n    fn get(&self) -> usize;\n}\n\nimpl<T> MyTrait for T {\n    fn get(&self) -> usize { 0 }\n}\n\nstruct Foo;\n\nfn main() {\n    let f = Foo;\n\n    f.get(); // the trait is implemented so we can use it\n}\n```\n"},"level":"error","spans":[{"file_name":"src/pb/sf.substreams.v1.rs","byte_start":1045,"byte_end":1061,"line_start":30,"line_end":30,"column_start":10,"column_end":26,"is_primary":false,"text":[{"text":"#[derive(::prost::Message)]","highlight_start":10,"highlight_end":26}],"label":"first implementation here","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/pb/sf.substreams.v1.rs","byte_start":1045,"byte_end":1061,"line_start":30,"line_end":30,"column_start":10,"column_end":26,"is_primary":false,"text":[{"text":"#[derive(::prost::Message)]","highlight_start":10,"highlight_end":26}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(::prost::Message)]","def_site_span":{"file_name":"/home/codespace/.cargo/registry/src/index.crates.io-6f17d22bba15001f/prost-derive-0.11.9/src/lib.rs","byte_start":7524,"byte_end":7573,"line_start":242,"line_end":242,"column_start":1,"column_end":50,"is_primary":false,"text":[{"text":"pub fn message(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":50}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/pb/sf.substreams.v1.rs","byte_start":1138,"byte_end":1154,"line_start":32,"line_end":32,"column_start":28,"column_end":44,"is_primary":true,"text":[{"text":"#[derive(Clone, PartialEq, ::prost::Message)]","highlight_start":28,"highlight_end":44}],"label":"conflicting implementation for `Value`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/pb/sf.substreams.v1.rs","byte_start":1138,"byte_end":1154,"line_start":32,"line_end":32,"column_start":28,"column_end":44,"is_primary":false,"text":[{"text":"#[derive(Clone, PartialEq, ::prost::Message)]","highlight_start":28,"highlight_end":44}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(::prost::Message)]","def_site_span":{"file_name":"/home/codespace/.cargo/registry/src/index.crates.io-6f17d22bba15001f/prost-derive-0.11.9/src/lib.rs","byte_start":7524,"byte_end":7573,"line_start":242,"line_end":242,"column_start":1,"column_end":50,"is_primary":false,"text":[{"text":"pub fn message(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":50}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0119]\u001b[0m\u001b[0m\u001b[1m: conflicting implementations of trait `Debug` for type `Value`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/pb/sf.substreams.v1.rs:32:28\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m30\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m#[derive(::prost::Message)]\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m----------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mfirst implementation here\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m31\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m#[allow(clippy::derive_partial_eq_without_eq)]\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m32\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m#[derive(Clone, PartialEq, ::prost::Message)]\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mconflicting implementation for `Value`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the derive macro `::prost::Message` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"conflicting implementations of trait `Debug` for type `Array`","code":{"code":"E0119","explanation":"There are conflicting trait implementations for the same type.\n\nErroneous code example:\n\n```compile_fail,E0119\ntrait MyTrait {\n    fn get(&self) -> usize;\n}\n\nimpl<T> MyTrait for T {\n    fn get(&self) -> usize { 0 }\n}\n\nstruct Foo {\n    value: usize\n}\n\nimpl MyTrait for Foo { // error: conflicting implementations of trait\n                       //        `MyTrait` for type `Foo`\n    fn get(&self) -> usize { self.value }\n}\n```\n\nWhen looking for the implementation for the trait, the compiler finds\nboth the `impl<T> MyTrait for T` where T is all types and the `impl\nMyTrait for Foo`. Since a trait cannot be implemented multiple times,\nthis is an error. So, when you write:\n\n```\ntrait MyTrait {\n    fn get(&self) -> usize;\n}\n\nimpl<T> MyTrait for T {\n    fn get(&self) -> usize { 0 }\n}\n```\n\nThis makes the trait implemented on all types in the scope. So if you\ntry to implement it on another one after that, the implementations will\nconflict. Example:\n\n```\ntrait MyTrait {\n    fn get(&self) -> usize;\n}\n\nimpl<T> MyTrait for T {\n    fn get(&self) -> usize { 0 }\n}\n\nstruct Foo;\n\nfn main() {\n    let f = Foo;\n\n    f.get(); // the trait is implemented so we can use it\n}\n```\n"},"level":"error","spans":[{"file_name":"src/pb/sf.substreams.v1.rs","byte_start":1967,"byte_end":1983,"line_start":57,"line_end":57,"column_start":10,"column_end":26,"is_primary":false,"text":[{"text":"#[derive(::prost::Message)]","highlight_start":10,"highlight_end":26}],"label":"first implementation here","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/pb/sf.substreams.v1.rs","byte_start":1967,"byte_end":1983,"line_start":57,"line_end":57,"column_start":10,"column_end":26,"is_primary":false,"text":[{"text":"#[derive(::prost::Message)]","highlight_start":10,"highlight_end":26}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(::prost::Message)]","def_site_span":{"file_name":"/home/codespace/.cargo/registry/src/index.crates.io-6f17d22bba15001f/prost-derive-0.11.9/src/lib.rs","byte_start":7524,"byte_end":7573,"line_start":242,"line_end":242,"column_start":1,"column_end":50,"is_primary":false,"text":[{"text":"pub fn message(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":50}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/pb/sf.substreams.v1.rs","byte_start":2060,"byte_end":2076,"line_start":59,"line_end":59,"column_start":28,"column_end":44,"is_primary":true,"text":[{"text":"#[derive(Clone, PartialEq, ::prost::Message)]","highlight_start":28,"highlight_end":44}],"label":"conflicting implementation for `Array`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/pb/sf.substreams.v1.rs","byte_start":2060,"byte_end":2076,"line_start":59,"line_end":59,"column_start":28,"column_end":44,"is_primary":false,"text":[{"text":"#[derive(Clone, PartialEq, ::prost::Message)]","highlight_start":28,"highlight_end":44}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(::prost::Message)]","def_site_span":{"file_name":"/home/codespace/.cargo/registry/src/index.crates.io-6f17d22bba15001f/prost-derive-0.11.9/src/lib.rs","byte_start":7524,"byte_end":7573,"line_start":242,"line_end":242,"column_start":1,"column_end":50,"is_primary":false,"text":[{"text":"pub fn message(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":50}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0119]\u001b[0m\u001b[0m\u001b[1m: conflicting implementations of trait `Debug` for type `Array`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/pb/sf.substreams.v1.rs:59:28\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m57\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m#[derive(::prost::Message)]\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m----------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mfirst implementation here\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m58\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m#[allow(clippy::derive_partial_eq_without_eq)]\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m59\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m#[derive(Clone, PartialEq, ::prost::Message)]\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mconflicting implementation for `Array`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the derive macro `::prost::Message` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"duplicate definitions with name `operation`","code":{"code":"E0592","explanation":"This error occurs when you defined methods or associated functions with same\nname.\n\nErroneous code example:\n\n```compile_fail,E0592\nstruct Foo;\n\nimpl Foo {\n    fn bar() {} // previous definition here\n}\n\nimpl Foo {\n    fn bar() {} // duplicate definition here\n}\n```\n\nA similar error is E0201. The difference is whether there is one declaration\nblock or not. To avoid this error, you must give each `fn` a unique name.\n\n```\nstruct Foo;\n\nimpl Foo {\n    fn bar() {}\n}\n\nimpl Foo {\n    fn baz() {} // define with different name\n}\n```\n"},"level":"error","spans":[{"file_name":"src/pb/sf.substreams.v1.rs","byte_start":352,"byte_end":368,"line_start":10,"line_end":10,"column_start":28,"column_end":44,"is_primary":true,"text":[{"text":"#[derive(Clone, PartialEq, ::prost::Message)]","highlight_start":28,"highlight_end":44}],"label":"duplicate definitions for `operation`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/pb/sf.substreams.v1.rs","byte_start":352,"byte_end":368,"line_start":10,"line_end":10,"column_start":28,"column_end":44,"is_primary":false,"text":[{"text":"#[derive(Clone, PartialEq, ::prost::Message)]","highlight_start":28,"highlight_end":44}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(::prost::Message)]","def_site_span":{"file_name":"/home/codespace/.cargo/registry/src/index.crates.io-6f17d22bba15001f/prost-derive-0.11.9/src/lib.rs","byte_start":7524,"byte_end":7573,"line_start":242,"line_end":242,"column_start":1,"column_end":50,"is_primary":false,"text":[{"text":"pub fn message(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":50}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/pb/sf.substreams.v1.rs","byte_start":259,"byte_end":275,"line_start":8,"line_end":8,"column_start":10,"column_end":26,"is_primary":false,"text":[{"text":"#[derive(::prost::Message)]","highlight_start":10,"highlight_end":26}],"label":"other definition for `operation`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/pb/sf.substreams.v1.rs","byte_start":259,"byte_end":275,"line_start":8,"line_end":8,"column_start":10,"column_end":26,"is_primary":false,"text":[{"text":"#[derive(::prost::Message)]","highlight_start":10,"highlight_end":26}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(::prost::Message)]","def_site_span":{"file_name":"/home/codespace/.cargo/registry/src/index.crates.io-6f17d22bba15001f/prost-derive-0.11.9/src/lib.rs","byte_start":7524,"byte_end":7573,"line_start":242,"line_end":242,"column_start":1,"column_end":50,"is_primary":false,"text":[{"text":"pub fn message(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":50}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0592]\u001b[0m\u001b[0m\u001b[1m: duplicate definitions with name `operation`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/pb/sf.substreams.v1.rs:10:28\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m8\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m#[derive(::prost::Message)]\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m----------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mother definition for `operation`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m9\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m#[allow(clippy::derive_partial_eq_without_eq)]\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m10\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m#[derive(Clone, PartialEq, ::prost::Message)]\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mduplicate definitions for `operation`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the derive macro `::prost::Message` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"duplicate definitions with name `set_operation`","code":{"code":"E0592","explanation":"This error occurs when you defined methods or associated functions with same\nname.\n\nErroneous code example:\n\n```compile_fail,E0592\nstruct Foo;\n\nimpl Foo {\n    fn bar() {} // previous definition here\n}\n\nimpl Foo {\n    fn bar() {} // duplicate definition here\n}\n```\n\nA similar error is E0201. The difference is whether there is one declaration\nblock or not. To avoid this error, you must give each `fn` a unique name.\n\n```\nstruct Foo;\n\nimpl Foo {\n    fn bar() {}\n}\n\nimpl Foo {\n    fn baz() {} // define with different name\n}\n```\n"},"level":"error","spans":[{"file_name":"src/pb/sf.substreams.v1.rs","byte_start":352,"byte_end":368,"line_start":10,"line_end":10,"column_start":28,"column_end":44,"is_primary":true,"text":[{"text":"#[derive(Clone, PartialEq, ::prost::Message)]","highlight_start":28,"highlight_end":44}],"label":"duplicate definitions for `set_operation`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/pb/sf.substreams.v1.rs","byte_start":352,"byte_end":368,"line_start":10,"line_end":10,"column_start":28,"column_end":44,"is_primary":false,"text":[{"text":"#[derive(Clone, PartialEq, ::prost::Message)]","highlight_start":28,"highlight_end":44}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(::prost::Message)]","def_site_span":{"file_name":"/home/codespace/.cargo/registry/src/index.crates.io-6f17d22bba15001f/prost-derive-0.11.9/src/lib.rs","byte_start":7524,"byte_end":7573,"line_start":242,"line_end":242,"column_start":1,"column_end":50,"is_primary":false,"text":[{"text":"pub fn message(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":50}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/pb/sf.substreams.v1.rs","byte_start":259,"byte_end":275,"line_start":8,"line_end":8,"column_start":10,"column_end":26,"is_primary":false,"text":[{"text":"#[derive(::prost::Message)]","highlight_start":10,"highlight_end":26}],"label":"other definition for `set_operation`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/pb/sf.substreams.v1.rs","byte_start":259,"byte_end":275,"line_start":8,"line_end":8,"column_start":10,"column_end":26,"is_primary":false,"text":[{"text":"#[derive(::prost::Message)]","highlight_start":10,"highlight_end":26}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(::prost::Message)]","def_site_span":{"file_name":"/home/codespace/.cargo/registry/src/index.crates.io-6f17d22bba15001f/prost-derive-0.11.9/src/lib.rs","byte_start":7524,"byte_end":7573,"line_start":242,"line_end":242,"column_start":1,"column_end":50,"is_primary":false,"text":[{"text":"pub fn message(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":50}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0592]\u001b[0m\u001b[0m\u001b[1m: duplicate definitions with name `set_operation`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/pb/sf.substreams.v1.rs:10:28\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m8\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m#[derive(::prost::Message)]\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m----------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mother definition for `set_operation`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m9\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m#[allow(clippy::derive_partial_eq_without_eq)]\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m10\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m#[derive(Clone, PartialEq, ::prost::Message)]\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mduplicate definitions for `set_operation`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the derive macro `::prost::Message` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"aborting due to 19 previous errors; 1 warning emitted","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: aborting due to 19 previous errors; 1 warning emitted\u001b[0m\n\n"}
{"message":"Some errors have detailed explanations: E0119, E0592.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1mSome errors have detailed explanations: E0119, E0592.\u001b[0m\n"}
{"message":"For more information about an error, try `rustc --explain E0119`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1mFor more information about an error, try `rustc --explain E0119`.\u001b[0m\n"}
